# Linux C编程一站式学习

## PART I C语言入门

### 转义符
![]




### 关键词
![]



### 变量的作用域
局部变量可以用类型相符的任意表达式来初始化，而全局变量只能用常量表达式（Constant Expression）初始化。
程序开始运行时要用适当的值来初始化全局变量，所以初始值必须保存在编译生成的可执行文件中，因此初始值在编译时就要计算出来，然而上面第二种Initializer的值必须在程序运行时调用acos函数才能得到，所以不能用来初始化全局变量。请注意区分编译时和运行时这两个概念。为了简化编译器的实现，C语言从语法上规定全局变量只能用常量表达式来初始化，因此下面这种全局变量初始化是不合法的：
```
int minute = 360;
int hour = minute / 60;
```


### switch语句
* case后面跟表达式的必须是常量表达式，这个值和全局变量的初始值一样必须在编译时计算出来。
* 在“if/else语句”中浮点型不适合做精确比较，所以C语言规定case后面跟的必须是整型常量表达式。
* 进入case后如果没有遇到break语句就会一直往下执行，后面其它case或default分支的语句也会被执行到，直到遇到break，或者执行到整个switch语句块的末尾。通常每个case后面都要加上break语句，但有时会故意不加break来利用这个特性，例如：
![]


### 递归和迭代
其实每次递归调用都在重复做同样一件事，就是把n乘到(n-1)!上然后把结果返回。虽说是重复，但每次做都稍微有一点区别（n的值不一样），这种每次都有一点区别的重复工作称为迭代（Iteration）。我们使用计算机的主要目的之一就是让它做重复迭代的工作，因为把一件工作重复做成千上万次而不出错正是计算机最擅长的，也是人类最不擅长的。虽然迭代用递归来做就够了，但C语言提供了循环语句使迭代程序写起来更方便。




### a+++++b
> 我们看一个有意思的问题：a+++++b这个表达式如何理解？应该理解成a++ ++ +b还是a++ + ++b，还是a + ++ ++b呢？应该按第一种方式理解。编译的过程分为词法解析和语法解析两个阶段，在词法解析阶段，编译器总是从前到后找最长的合法Token。把这个表达式从前到后解析，变量名a是一个Token，a后面有两个以上的+号，在C语言中一个+号是合法的Token（可以是加法运算符或正号），两个+号也是合法的Token（可以是自增运算符），根据最长匹配原则，编译器绝不会止步于一个+号，而一定会把两个+号当作一个Token。再往后解析仍然有两个以上的+号，所以又是一个++运算符。再往后解析只剩一个+号了，是加法运算符。再往后解析是变量名b。
> 词法解析之后进入下一阶段语法解析，a是一个表达式，表达式++还是表达式，表达式再++还是表达式，表达式再+b还是表达式，语法上没有问题。最后编译器会做一些基本的语义分析，这时就有问题了，++运算符要求操作数能做左值，a能做左值所以a++没问题，但表达式a++的值只能做右值，不能再++了，所以最终编译器会报错。
```
((a++)++)+b
```


### 结构体
定义一个结构体
```
struct complex_struct {
	double x, y;
};
```
在定义结构体类型的同时定义了变量
```
struct complex_struct {
	double x, y;
} z1, z2;
struct {
	double x, y;
} z1, z2;	//但这样就没办法再次引用这个结构体类型了，因为它没有名字。
```


### 数据类型标志
enum关键字的作用和struct关键字类似，把coordinate_type这个标识符定义为一个Tag，struct complex_struct表示一个结构体类型，而enum coordinate_type表示一个枚举（Enumeration）类型。枚举类型的成员是常量，它们的值由编译器自动分配，例如定义了上面的枚举类型之后，RECTANGULAR就表示常量0，POLAR表示常量1。
```
enum coordinate_type { RECTANGULAR, POLAR };
struct complex_struct {
	enum coordinate_type t;
	double a, b;
};
```



### 数组
数组下标也可以是表达式，但表达式的值必须是整型的。例如：
```
int i = 10;
count[i] = count[i+1];
```
使用数组下标不能超出数组的长度范围，这一点在使用变量做数组下标时尤其要注意。C编译器并不检查count[-1]或是count[100]这样的访问越界错误，编译时能顺利通过，所以属于运行时错误[17]。但有时候这种错误很隐蔽，发生访问越界时程序可能并不会立即崩溃，而执行到后面某个正确的语句时却有可能突然崩溃（在第 4 节 “段错误”我们会看到这样的例子）。所以从一开始写代码时就要小心避免出问题，事后依靠调试来解决问题的成本是很高的。

数组也可以像结构体一样初始化，未赋初值的元素也是用0来初始化，例如：
```
int count[4] = { 3, 2, };
```
则`count[0]`等于`3`，`count[1]`等于`2`，后面两个元素等于`0`。如果定义数组的同时初始化它，也可以不指定数组的长度，例如：
```
int count[] = { 3, 2, 1, };
```



## PART II C语言本质

### 位运算

#### 按位与、或、异或、取反运算
C语言提供了按位与（Bitwise AND）运算符&
按位或（Bitwise OR）运算符|
按位取反（Bitwise NOT）运算符~
此外还有按位异或（Bitwise XOR）运算符^

##### 异或
* 一个数自己和自己异或结果是0
* 和0做异或保持原值不变，和1做异或得到原值的相反值。
* 奇偶校验：n个位的异或结果是1，说明其中1的个数是奇数，否则为偶数个。
* x ^ x ^ y == y，因为x ^ x == 0，0 ^ y == y。这个性质有什么用呢？我们来看这样一个问题：交换两个变量的值，不得借助额外的存储空间，所以就不能采用temp = a; a = b; b = temp;的办法了。利用位运算可以这样做交换：
```
a = a ^ b;
b = b ^ a;  // b ^ a ^ b -> a
a = a ^ b;  // a ^ b ^ b ^ a ^ b -> b
```

#### 移位运算
移位运算符（Bitwise Shift）包括左移<<和右移>>。左移将一个整数的各二进制位全部左移若干位，例如`0xcfffffff3<<2`得到`0x3fffffcc`、`0xcfffffff3>>2`得到`0x33fffffc`
在一定的取值范围内，将一个整数右移1位相当于除以2，小数部分截掉。

当操作数是有符号数时，右移运算的规则比较复杂
* 如果是正数，那么高位移入0
* 如果是负数，那么高位移入1还是0不一定，这是Implementation-defined的。对于x86平台的gcc编译器，最高位移入1，也就是仍保持负数的符号位，这种处理方式对负数仍然保持了“右移1位相当于除以2”的性质。

> 建议只对无符号数做位运算，以减少出错的可能。



### 寻址方式
* 直接寻址（Direct Addressing Mode）。只使用ADDRESS_OR_OFFSET寻址，例如movl ADDRESS, %eax把ADDRESS地址处的32位数传送到eax寄存器。
* 变址寻址（Indexed Addressing Mode） 。上一节的movl data_items(,%edi,4), %eax就属于这种寻址方式，用于访问数组元素比较方便。
* 间接寻址（Indirect Addressing Mode）。只使用BASE_OR_OFFSET寻址，例如movl (%eax), %ebx，把eax寄存器的值看作地址，把内存中这个地址处的32位数传送到ebx寄存器。注意和movl %eax, %ebx区分开。
* 基址寻址（Base Pointer Addressing Mode）。只使用ADDRESS_OR_OFFSET和BASE_OR_OFFSET寻址，例如movl 4(%eax), %ebx，用于访问结构体成员比较方便，例如一个结构体的基地址保存在eax寄存器中，其中一个成员在结构体内的偏移量是4字节，要把这个成员读上来就可以用这条指令。
* 立即数寻址（Immediate Mode）。就是指令中有一个操作数是立即数，例如movl $12, %eax中的$12，这其实跟寻址没什么关系，但也算作一种寻址方式。
* 寄存器寻址（Register Addressing Mode）。就是指令中有一个操作数是寄存器，例如movl $12, %eax中的%eax，这跟内存寻址没什么关系，但也算作一种寻址方式。在汇编程序中寄存器用助记符来表示，在机器指令中则要用几个Bit表示寄存器的编号，这几个Bit也可以看作寄存器的地址，但是和内存地址不在一个地址空间。

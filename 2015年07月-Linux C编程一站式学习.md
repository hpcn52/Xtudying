# Linux C编程一站式学习

> 来源 http://akaedu.github.io/book/index.html

## PART I C语言入门

### 转义符
![转义符](https://github.com/hp52/Xtudying/image/c_2.jpg)




### 关键词
![c_keywords](https://github.com/hp52/Xtudying/image/c_keywords.jpg)



### 变量的作用域
**局部变量可以用类型相符的任意表达式来初始化，而全局变量只能用常量表达式（Constant Expression）初始化。**

程序开始运行时要用适当的值来初始化全局变量，所以初始值必须保存在编译生成的可执行文件中，因此初始值在编译时就要计算出来，然而上面第二种Initializer的值必须在程序运行时调用acos函数才能得到，所以不能用来初始化全局变量。请注意区分编译时和运行时这两个概念。为了简化编译器的实现，C语言从语法上规定全局变量只能用常量表达式来初始化，因此下面这种全局变量初始化是不合法的：

```c
int minute = 360;
int hour = minute / 60;
```

> 疑问：全局变量只能用常量来初始化，但初始化后可以用变量来赋值吗？


### switch语句
* case后面跟表达式的必须是常量表达式，这个值和全局变量的初始值一样必须在编译时计算出来。
* 在“if/else语句”中浮点型不适合做精确比较，所以C语言规定case后面跟的必须是整型常量表达式。
* 进入case后如果没有遇到break语句就会一直往下执行，后面其它case或default分支的语句也会被执行到，直到遇到break，或者执行到整个switch语句块的末尾。通常每个case后面都要加上break语句，但有时会故意不加break来利用这个特性，例如：
![c_switch](https://github.com/hp52/Xtudying/image/c_switch.jpg)


### 递归和迭代
其实每次递归调用都在重复做同样一件事，就是把n乘到(n-1)!上然后把结果返回。虽说是重复，但每次做都稍微有一点区别（n的值不一样），这种每次都有一点区别的重复工作称为迭代（Iteration）。

我们使用计算机的主要目的之一就是让它做重复迭代的工作，因为把一件工作重复做成千上万次而不出错正是计算机最擅长的，也是人类最不擅长的。虽然迭代用递归来做就够了，但C语言提供了循环语句使迭代程序写起来更方便。




### a+++++b
>     我们看一个有意思的问题：a+++++b这个表达式如何理解？

> 应该理解成a++ ++ +b还是a++ + ++b，还是a + ++ ++b呢？应该按第一种方式理解。编译的过程分为词法解析和语法解析两个阶段，在词法解析阶段，编译器总是从前到后找最长的合法Token。把这个表达式从前到后解析，变量名a是一个Token，a后面有两个以上的+号，在C语言中一个+号是合法的Token（可以是加法运算符或正号），两个+号也是合法的Token（可以是自增运算符），根据最长匹配原则，编译器绝不会止步于一个+号，而一定会把两个+号当作一个Token。再往后解析仍然有两个以上的+号，所以又是一个++运算符。再往后解析只剩一个+号了，是加法运算符。再往后解析是变量名b。

> 词法解析之后进入下一阶段语法解析，a是一个表达式，表达式++还是表达式，表达式再++还是表达式，表达式再+b还是表达式，语法上没有问题。最后编译器会做一些基本的语义分析，这时就有问题了，++运算符要求操作数能做左值，a能做左值所以a++没问题，但表达式a++的值只能做右值，不能再++了，所以最终编译器会报错。

```c
((a++)++)+b
```


### 结构体
定义一个结构体
```c
struct complex_struct {
	double x, y;
};
```
在定义结构体类型的同时定义了变量
```c
struct complex_struct {
	double x, y;
} z1, z2;
struct {
	double x, y;
} z1, z2;	//但这样就没办法再次引用这个结构体类型了，因为它没有名字。
```


### 数据类型标志
enum关键字的作用和struct关键字类似，把coordinate_type这个标识符定义为一个Tag，struct complex_struct表示一个结构体类型，而enum coordinate_type表示一个枚举（Enumeration）类型。枚举类型的成员是常量，它们的值由编译器自动分配，例如定义了上面的枚举类型之后，RECTANGULAR就表示常量0，POLAR表示常量1。
```c
enum coordinate_type { RECTANGULAR, POLAR };
struct complex_struct {
	enum coordinate_type t;
	double a, b;
};
```



### 数组
数组下标也可以是表达式，但表达式的值必须是整型的。例如：
```c
int i = 10;
count[i] = count[i+1];
```
使用数组下标不能超出数组的长度范围，这一点在使用变量做数组下标时尤其要注意。C编译器并不检查count[-1]或是count[100]这样的访问越界错误，编译时能顺利通过，所以属于运行时错误[17]。但有时候这种错误很隐蔽，发生访问越界时程序可能并不会立即崩溃，而执行到后面某个正确的语句时却有可能突然崩溃（在第 4 节 “段错误”我们会看到这样的例子）。所以从一开始写代码时就要小心避免出问题，事后依靠调试来解决问题的成本是很高的。

> 段错误：内存溢出，读了不该读的，写了不该写的

> 野指针：指向了不确定的内存地址

数组也可以像结构体一样初始化，未赋初值的元素也是用0来初始化，例如：
```c
int count[4] = { 3, 2, };
```
则`count[0]`等于`3`，`count[1]`等于`2`，后面两个元素等于`0`。如果定义数组的同时初始化它，也可以不指定数组的长度，例如：
```c
int count[] = { 3, 2, 1, };
```



## PART II C语言本质

### 位运算

#### 按位与、或、异或、取反运算
* C语言提供了按位与（Bitwise AND）运算符`&`
* 按位或（Bitwise OR）运算符`|`
* 按位取反（Bitwise NOT）运算符`~`
* 此外还有按位异或（Bitwise XOR）运算符`^`

##### 异或
* 一个数自己和自己异或结果是0
* 和0做异或保持原值不变，和1做异或得到原值的相反值。
* 奇偶校验：n个位的异或结果是1，说明其中1的个数是奇数，否则为偶数个。
* x ^ x ^ y == y，因为x ^ x == 0，0 ^ y == y。这个性质有什么用呢？我们来看这样一个问题：交换两个变量的值，不得借助额外的存储空间，所以就不能采用temp = a; a = b; b = temp;的办法了。利用位运算可以这样做交换：
```c
a = a ^ b;
b = b ^ a;  // b ^ a ^ b -> a
a = a ^ b;  // a ^ b ^ b ^ a ^ b -> b
```

#### 移位运算
移位运算符（Bitwise Shift）包括左移<<和右移>>。左移将一个整数的各二进制位全部左移若干位，例如`0xcfffffff3<<2`得到`0x3fffffcc`、`0xcfffffff3>>2`得到`0x33fffffc`
在一定的取值范围内，将一个整数右移1位相当于除以2，小数部分截掉。

> 当操作数是有符号数时，右移运算的规则比较复杂

* 如果是正数，那么高位移入0
* 如果是负数，那么高位移入1还是0不一定，这是Implementation-defined的。对于x86平台的gcc编译器，最高位移入1，也就是仍保持负数的符号位，这种处理方式对负数仍然保持了“右移1位相当于除以2”的性质。

**建议只对无符号数做位运算，以减少出错的可能。**



### 寻址方式
* 直接寻址（Direct Addressing Mode）。只使用ADDRESS_OR_OFFSET寻址，例如movl ADDRESS, %eax把ADDRESS地址处的32位数传送到eax寄存器。
* 变址寻址（Indexed Addressing Mode） 。上一节的movl data_items(,%edi,4), %eax就属于这种寻址方式，用于访问数组元素比较方便。
* 间接寻址（Indirect Addressing Mode）。只使用BASE_OR_OFFSET寻址，例如movl (%eax), %ebx，把eax寄存器的值看作地址，把内存中这个地址处的32位数传送到ebx寄存器。注意和movl %eax, %ebx区分开。
* 基址寻址（Base Pointer Addressing Mode）。只使用ADDRESS_OR_OFFSET和BASE_OR_OFFSET寻址，例如movl 4(%eax), %ebx，用于访问结构体成员比较方便，例如一个结构体的基地址保存在eax寄存器中，其中一个成员在结构体内的偏移量是4字节，要把这个成员读上来就可以用这条指令。
* 立即数寻址（Immediate Mode）。就是指令中有一个操作数是立即数，例如movl $12, %eax中的$12，这其实跟寻址没什么关系，但也算作一种寻址方式。
* 寄存器寻址（Register Addressing Mode）。就是指令中有一个操作数是寄存器，例如movl $12, %eax中的%eax，这跟内存寻址没什么关系，但也算作一种寻址方式。在汇编程序中寄存器用助记符来表示，在机器指令中则要用几个Bit表示寄存器的编号，这几个Bit也可以看作寄存器的地址，但是和内存地址不在一个地址空间。
<<<<<<< HEAD





### 指针

```c
int i;
int *pi = &i;
char c;
char *pc = &c;
```

`&`是**取地址运算符**（Address Operator），**&i表示取变量i的地址**，`int *pi = &i;`表示定义一个指向int型的指针变量pi，并用i的地址来初始化pi。我们讲过全局变量只能用常量表达式初始化，如果定义`int p = i;`就错了，因为i不是常量表达式，然而用i的地址来初始化一个指针却没有错，因为i的地址是在编译链接时能确定的，而不需要到运行时才知道，&i是常量表达式。后面两行代码定义了一个字符型变量c和一个指向c的字符型指针pc，**注意pi和pc虽然是不同类型的指针变量，但它们的内存单元都占4个字节，因为要保存32位的虚拟地址，同理，在64位平台上指针变量都占8个字节。**

`*`号是**指针间接寻址运算符**（Indirection Operator），`*pi`表示取`指针pi`所指向的变量的值，也称为Dereference操作，指针有时称为变量的引用（Reference），所以根据指针找到变量称为Dereference。

`&`运算符的操作数必须是左值，因为只有左值才表示一个内存单元，才会有地址，运算结果是指针类型。

`*`运算符的操作数必须是指针类型，运算结果可以做左值。

所以，如果表达式`E`可以做左值，`*&E`和`E`等价，如果表达式`E`是指针类型，`&*E`和`E`等价。



#### 指针与数组
先看个例子，有如下语句：

```c
int a[10];
int *pa = &a[0];
pa++;
```

首先指针pa指向a[0]的地址，注意后缀运算符的优先级高于单目运算符，所以是取a[0]的地址，而不是取a的地址。然后pa++让pa指向下一个元素（也就是a[1]），由于pa是int *指针，一个int型元素占4个字节，所以pa++使pa所指向的地址加4，注意不是加1。

从前面的例子我们发现，地址的具体数值其实无关紧要，关键是要说明地址之间的关系（a[1]位于a[0]之后4个字节处）以及指针与变量之间的关系（指针保存的是变量的地址），现在我们换一种画法，省略地址的具体数值，用方框表示存储空间，用箭头表示指针和变量之间的关系。

在函数原型中，如果参数是数组，则等价于参数是指针的形式，例如：

```c
void func(int a[10])
{
	...
}
```

等价于：

```c
void func(int *a)
{
	...
}
```

第一种形式方括号中的数字可以不写，仍然是等价的：

```c
void func(int a[])
{
	...
}
```


#### const限定符

const限定符和指针结合起来常见的情况有以下几种。

```c
const int *a;
int const *a;
```

这两种写法是一样的，a是一个指向const int型的指针，a所指向的内存单元不可改写，所以(*a)++是不允许的，但a可以改写，所以a++是允许的。

```c
int * const a;
```

a是一个指向int型的const指针，*a是可以改写的，但a不允许改写。

```c
int const * const a;
```
如果要定义一个指针指向字符串字面值，这个指针应该是`const char *`型，如果写成`char *p = "abcd";`就不好了，有隐患。


#### 指针和结构

首先定义一个结构体类型，然后定义这种类型的变量和指针：

```c
struct unit {
	char c;
	int num;
};
struct unit u;
struct unit *p = &u;
```

要通过指针p访问结构体成员可以写成`(*p).c`和`(*p).num`，为了书写方便，C语言提供了`->`运算符，也可以写成`p->c`和`p->num`。


#### 指向指针的指针与指针数组

指针可以指向基本类型，也可以指向复合类型，因此也可以指向另外一个指针变量，称为指向指针的指针。
```c
int i;
int *pi = &i;
int **ppi = &pi;
```
这样定义之后，表达式*ppi取pi的值，表达式**ppi取i的值。

##### 打印命令行参数
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
	int i;
	for(i = 0; i < argc; i++)
		printf("argv[%d]=%s\n", i, argv[i]);
	return 0;
}
```
```Bash
$ gcc main.c
$ ./a.out a b c
argv[0]=./a.out
argv[1]=a
argv[2]=b
argv[3]=c
```


#### 指向数组的指针与多维数组
指针可以指向复合类型，这一节学习指向数组的指针。以下定义一个指向数组的指针，该数组有10个int元素：
```c
int (*a)[10];
```
> 定义以下变量：

```c
char a[4][3][2] = {{{'a', 'b'}, {'c', 'd'}, {'e', 'f'}},
    	   {{'g', 'h'}, {'i', 'j'}, {'k', 'l'}},
		   {{'m', 'n'}, {'o', 'p'}, {'q', 'r'}},
		   {{'s', 't'}, {'u', 'v'}, {'w', 'x'}}};

char (*pa)[2] = &a[1][0];
char (*ppa)[3][2] = &a[1];
```

> 要想通过pa或ppa访问数组a中的'r'元素，分别应该怎么写？

```c
(*pa++);
(*pa++);
(*pa++);
(*pa++);
(*pa++);
printf("\n*pa++ %d times, [0]=%c, [1]=%c\n",i , (*pa)[0], (*pa)[1]);

(*ppa++);
printf("\n *ppa = %c \n",(*ppa)[2][1]);
```

#### 函数类型和函数指针类型








#### 不完全类型和复杂声明